import BlogPostShell from "../components/BlogPostShell";
import { Grid } from "theme-ui";
import DrawV1 from "../components/Draw/1";
import DrawV2 from "../components/Draw/2";
import DrawV3 from "../components/Draw/3";

export default ({ children }) => <BlogPostShell>{children}</BlogPostShell>;

# Performant shared state with Recoil

Monday, 25 May 2020

- [Introduction](#introduction)
- [Specs: Drawing App](#specs-drawing-app)
- [Testing drag and drop](#testing-drag-and-drop)
- [Step 1: Local state](#step-1-local-state)
- [Step 2: Shared state](#step-2-shared-state)
- [Step 3: Shared state with Recoil](#step-3-shared-state-with-recoil)
- [Summary](#summary)

## Introduction

So I built a prototype to get a feel of Facebook's state management library, Recoil, and want to share my experience. Made a small app using React state, and then refactored it to sharing global state with Recoil.

One of Recoil's use cases is avoiding shared global state by sharing data between child elements, instead of sharing state in their common parent. The main benefit of not having this top-level shared state is preventing unnecesary re-renders. Since it's "just" a performance benefit, you need to be careful not to prematurely optimize. Re-rendering in itself does not imply performance problems. React's reconciliation algorithm makes sure to efficiently update the DOM as best as it can. So a re-render could cause React to update a property in a dom element, which is a performant operation. On the other hand, it could cause unmounting and remounting the component tree, which could very well be a performance problem. As a general rule, I love to strive for working code, then idiomatic code and only optimize if it's necessary.

The goal of this prototype is to build an app that kinda resembles a drawing application, as opposed to the typical text based todo-like demo application, since it's a more likely target to benefit from Recoil's potential performance benefits.

Recoil provides the following features:

- Flexible shared state
- Derived data and queries
- App-wide state observation

The focus of this guide will be on the first feature, flexible shared state. After watching the an introductory talk given by one of Recoil's creators, I decided to delve deep into the first beenfit, which is explained in the first 12 minutes of that talk. Be sure to watch it before or after reading this post, it's a really well explained intro to Recoil. Also check out it's [official docs](https://recoiljs.org/) if you want to learn more. And here's a preview of the talk I mentioned:

<div
  style={{ display: "flex", justifyContent: "center", alignItems: "center" }}
>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/fb3cOMFkEzs"
    frameBorder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

First I'll write down the specs of the demo app, to clarify its scope and use cases.

## Specs: Drawing App

It's an app with a top level toolbar that lets you drag squares onto the screen. This kind of application sounds like a prime candidate for the optimisation that Recoil provides, since these kinds of applications need to be prepared to render many elements on the screen, while still providing fluid interactions. This is a similar project to the app demoed in the Recoil talk mentioned in the introduction, but simplified and with full access to its source code.

There are three main requirements:

- Users should be able to create rectangles by dragging onto canvas
- They should be able to move rectangles by dragging on canvas
- Finally, they should see the rectangles' positions in a sidebar

To illustrate them a bit better, take a look at the following mocks:

<Grid columns={[1, 1, 3]}>
  <div>
    <img src="/create-rect.png" />
    <div style={{ display: "flex", justifyContent: "center" }}>
      Create rectangle
    </div>
  </div>
  <div>
    <img src="/move-rect.png" />
    <div style={{ display: "flex", justifyContent: "center" }}>
      Move rectangle
    </div>
  </div>
  <div>
    <img src="/rect-info.png" />
    <div style={{ display: "flex", justifyContent: "center" }}>
      Rectangle information
    </div>
  </div>
</Grid>

The next step will be translating the app's requirements to automated tests.

## Testing drag and drop

To test the first requirement, you need to simulate a user dragging from the toolbar to the canvas, and verifying that a new rectangle appeared.

Testing for moving rectangles is similar to testing creation, because it needs to simulate a drag to create, and afterwards simulate dragging a rectangle to another point on the canvas.

```js
test("creates rectangles", () => {
  const { getByTestId } = render(<Draw />);
  const rectangleCreator = getByTestId("rectangle-creator");
  const canvas = getByTestId("canvas");
  // Create rectangle by dragging from rectangle creator to the canvas
  drag(
    { element: rectangleCreator, clientX: 50, clientY: 50 },
    { element: canvas, clientX: 100, clientY: 100 }
  );
  const rectangles = canvas.querySelectorAll(".rectangle");
  expect(rectangles.length).toBe(1);
  expect(rectangles[0].style.left).toBe("70px");
  expect(rectangles[0].style.top).toBe("70px");
});

test("moves rectangles", () => {
  const { getByTestId } = render(<Draw />);
  const rectangleCreator = getByTestId("rectangle-creator");
  const canvas = getByTestId("canvas");
  // Create rectangle by dragging from rectangle creator to the canvas
  drag(
    { element: rectangleCreator, clientX: 50, clientY: 50 },
    { element: canvas, clientX: 100, clientY: 100 }
  );
  const rectangles = canvas.querySelectorAll(".rectangle");
  // Move rectangle by dragging from it another position on the canvas
  drag(
    { element: rectangles[0], clientX: 100, clientY: 100 },
    { element: canvas, clientX: 200, clientY: 200 }
  );
  expect(rectangles[0].style.left).toBe("170px");
  expect(rectangles[0].style.top).toBe("170px");
});
```

To achieve the previous tests I built a `drag` function. It takes two parameters, an object representing where to start dragging, and an object representing where to stop dragging.

```js
/**
 * Utility to simulate dragging from an element to another
 *
 * Fires dragStart event on the `from` element, at position `clientX` and `clientY`,
 * where `clientX` and `clientY` refer to viewport coordinates
 * Then fires dragOver event halfway between `from` and `to` elements
 * Finaly fires dragEnd to the `from` element, and drop to the `to` element
 *
 * Arguments:
 * - `from`: { element, clientX, clientY }
 * - `to`: { element, clientX, clientY }
 */
function drag(from, to) {
  const data = {};
  const dataTransfer = {
    setData: (key, newData) => {
      data[key] = newData;
    },
    getData: (key) => data[key],
  };
  fireEvent.dragStart(from.element, {
    clientX: from.clientX,
    clientY: from.clientY,
    dataTransfer,
  });
  fireEvent.dragOver(to.element, {
    clientX: to.clientX - from.clientX / 2,
    clientY: to.clientY - from.clientY / 2,
    dataTransfer,
  });
  const dropEvent = new Event("drop", {
    bubbles: true,
    cancelable: true,
    composed: true,
    EventType: "DragEvent",
  });
  // Wrap drop event with `act` because it will trigger updates to the components
  act(() => {
    Object.defineProperty(dropEvent, "clientX", { value: to.clientX });
    Object.defineProperty(dropEvent, "clientY", { value: to.clientY });
    Object.defineProperty(dropEvent, "dataTransfer", { value: dataTransfer });
    to.element.dispatchEvent(dropEvent);
  });
  fireEvent.dragEnd(from.element, {
    clientX: to.clientX,
    clientY: to.clientY,
    dataTransfer,
  });
}
```

## Step 1: Local state

To implement the first requirement, allowing users to create rectangles, the app will hold a list of them with just their ids in the root component, and each rectangle's position in their local state. The main reason for storing them in the local state is so that moving a rectangle results in a re-render of just that component.

There are three components that make this interaction possible:

- A top level which holds an array of rectangles in state, passing to them the list of rectangles and a function to add new elements to that list.
- A toolbar that has a `<RectangleCreator />`, which is in charge of creating new rectangles at the end of a drag interaction.
- `Canvas`, which is a drop zone and is also in charge of rendering all rectangles.
- `Rectangle` which displays a rectangle on the screen, holding it's `x` and `y` position in it's local state. It's position is relative to the canvas. It also has dragging logic to update it's local position after dropping it on another part of the canvas.

To handle dragging and dropping this component uses react-dnd. The main reason is the idiomatic, hooks-based react API which allows declaring `Canvas` as a drop zone, and `RectangleCreator` as a draggable item.

Here's the implementation in action, try it out! Drag the square thingy from the top to create some rectangles, and then move them around.

<DrawV1 />

```js codesandbox=recoil
import React, { useState } from "react";
import { DndProvider, useDrop } from "react-dnd";
import Backend from "react-dnd-html5-backend";
import { useDrag } from "react-dnd";

export default function Draw() {
  const [rectangles, setRectangles] = useState([]);

  return (
    <DndProvider backend={Backend}>
      <div style={{ width: "100%", border: "solid 1px #999" }}>
        <div
          style={{
            width: "100%",
            height: 50,
            borderBottom: "solid 1px #999",
            padding: 10,
            display: "flex",
            alignItems: "center",
          }}
        >
          <RectangleCreator
            onCreate={(rectangle) => {
              setRectangles([...rectangles, rectangle]);
            }}
          />
        </div>
        <Canvas>
          {rectangles.map((rectangle) => (
            <Rectangle key={rectangle.id} rectangle={rectangle} />
          ))}
        </Canvas>
      </div>
    </DndProvider>
  );
}

/**
 * Container that allows dropping items onto it
 */
function Canvas({ children }) {
  let canvasRef;
  const [, drop] = useDrop({
    accept: [ItemTypes.RECTANGLE_CREATOR, ItemTypes.RECTANGLE],
    drop: (item, monitor) => {
      const clientOffset = monitor.getClientOffset();
      // Calculate position adjusted to the canvas, and set it to item so that it's accesible on the `end` function of the dragging element.
      // `viewportToCanvasPosition` translates viewport based mouse position to canvas-relative coordinates.
      if (item.type === ItemTypes.RECTANGLE_CREATOR) {
        item.dropPosition = viewportToCanvasPosition(canvasRef, {
          x: clientOffset.x,
          y: clientOffset.y,
        });
      } else if (item.type === ItemTypes.RECTANGLE) {
        item.dropPosition = viewportToCanvasPosition(canvasRef, {
          x: clientOffset.x,
          y: clientOffset.y,
        });
      }
      return { name: "Canvas", allowedDropEffect: "any" };
    },
  });
  return (
    <div
      data-testid="canvas"
      ref={(element) => {
        canvasRef = element;
        drop(element);
      }}
      style={{
        width: "100%",
        height: 500,
        position: "relative",
      }}
    >
      {children}
    </div>
  );
}

const ItemTypes = {
  RECTANGLE_CREATOR: "rectangle_creator",
  RECTANGLE: "rectangle",
};

/**
 * Element that can be dragged onto the canvas to create rectangles on the dropped position
 */
function RectangleCreator({ onCreate }) {
  const width = 60;
  const height = 60;
  const [, drag] = useDrag({
    item: { type: ItemTypes.RECTANGLE_CREATOR, width, height },
    end: (item, monitor) => {
      if (item.dropPosition) {
        const id = Date.now().toString();
        const rectangle = {
          id,
          // Subtract width and height to anchor on the middle, not top-left
          x: item.dropPosition.x - width / 2,
          y: item.dropPosition.y - height / 2,
          width,
          height,
        };
        onCreate(rectangle);
      }
    },
  });
  return (
    <>
      <div
        ref={drag}
        data-testid="rectangle-creator"
        style={{ backgroundColor: "#999", width: 30, height: 30 }}
      ></div>
    </>
  );
}

/**
 * Displays rectangle that can be moved by dragging it on the canvas
 */
function Rectangle({ rectangle }) {
  const [rectangleState, setRectangleState] = useState(rectangle);
  const setPosition = ({ x, y }) => {
    setRectangleState({
      ...rectangleState,
      // Subtract width and height to anchor on the middle, not top-left
      x: x - rectangleState.width / 2,
      y: y - rectangleState.height / 2,
    });
  };
  const [{ isDragging }, drag] = useDrag({
    item: {
      type: ItemTypes.RECTANGLE,
      width: rectangle.width,
      height: rectangle.height,
    },
    end: (item) => {
      if (item.dropPosition) {
        setPosition(item.dropPosition);
      }
    },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });
  const opacity = isDragging ? 0.4 : 1;
  return (
    <div
      ref={drag}
      className="rectangle"
      style={{
        backgroundColor: "#999",
        left: rectangleState.x,
        top: rectangleState.y,
        width: rectangleState.width,
        height: rectangleState.height,
        position: "absolute",
        opacity,
        cursor: "move",
      }}
    />
  );
}

// Convert viewport-relative positions to canvas-relative positions
function viewportToCanvasPosition(canvasRef, viewportPosition) {
  const canvasRect = canvasRef.getBoundingClientRect();
  let x = viewportPosition.x;
  x = x - canvasRect.left; // Convert mouse position which is relative to viewport, to a position relative to canvas
  let y = viewportPosition.y;
  y = y - canvasRect.top; // Convert mouse position which is relative to viewport, to a position relative to canvas
  return { x, y };
}
```

To sum up, this first step holds state in two parts:

1. Rectangle list on top level to keep track of their ids
1. Rectangle info on local state so that moving them does not re-render siblings

This approach works perfectly fine for now, moving rectangles across the canvas only re-renders the rectangle that moved. Let's see how adding a requirement changes how to manage rectangle state.

## Step 2: Shared state

Now comes the time to implement another feature, displaying each rectangle's position in a sidebar. To test this interaction, you need to simulate creating and rectangle and then use the same dragging logic to simulate moving a rectangle from point A to point B.

```js
test("display rectangles position", () => {
  const { getByTestId } = render(<Draw />);
  const rectangleCreator = getByTestId("rectangle-creator");
  const canvas = getByTestId("canvas");
  // Create rectangle by dragging from rectangle creator to the canvas
  drag(
    { element: rectangleCreator, clientX: 50, clientY: 50 },
    { element: canvas, clientX: 100, clientY: 100 }
  );
  const sidebar = getByTestId("sidebar");
  const sidebarRectangles = sidebar.querySelectorAll(".rectangle-info");
  expect(sidebarRectangles.length).toBe(1);
  expect(
    sidebarRectangles[0].querySelectorAll(".x-position")[0].textContent
  ).toContain("70");
  expect(
    sidebarRectangles[0].querySelectorAll(".y-position")[0].textContent
  ).toContain("70");
});
```

Now the sidebar component needs access to the rectangle's position, which is on their local state for the moment. To share this information between them, the root component can store each rectangle's `x` and `y` position, passing it down to each `Rectangle` component so it's positioned on the right side of the screen, and also to the sidebar component to display this information. So the solution is lifting state up.

Here's the new feature in action. Notice that now the top-level rectangles array holds `id`, `x` and `y` instead of just `id`.

There's also a new `RectangleInfo` component that displays a rectangle position. You can play around with the rectangles and see their position change as you move them.

<DrawV2 />

```js codesandbox=recoil
import React, { useState } from "react";
import { DndProvider, useDrop, useDrag } from "react-dnd";
import Backend from "react-dnd-html5-backend";
import { RecoilRoot, atom, useRecoilValue, useRecoilState } from "recoil";
import memoize from "memoizee";

function Draw() {
  const [rectangles, setRectangles] = useState([]);

  return (
    <DndProvider backend={Backend}>
      <div style={{ width: "100%", border: "solid 1px #999" }}>
        <div style={{ display: "flex", flexDirection: "row" }}>
          <div
            data-testid="sidebar"
            style={{
              flexBasis: "100px",
              borderRight: "solid 1px #999",
              paddingTop: 50,
            }}
          >
            {rectangles.map((rectangle) => (
              <RectangleInfo key={rectangle.id} rectangle={rectangle} />
            ))}
          </div>
          <div style={{ flex: 1 }}>
            <div
              style={{
                width: "100%",
                height: 50,
                borderBottom: "solid 1px #999",
                padding: 10,
                display: "flex",
                alignItems: "center",
              }}
            >
              <RectangleCreator
                onCreate={(rectangle) => {
                  setRectangles([...rectangles, rectangle]);
                }}
              />
            </div>
            <Canvas>
              {rectangles.map((rectangle) => (
                <Rectangle key={rectangle.id} rectangle={rectangle} />
              ))}
            </Canvas>
          </div>
        </div>
      </div>
    </DndProvider>
  );
}

export default () => (
  <RecoilRoot>
    <Draw />
  </RecoilRoot>
);

function RectangleInfo({ rectangle }) {
  const rectangleValue = useRecoilValue(rectangleAtom(rectangle));
  return (
    <div
      className="rectangle-info"
      style={{
        display: "flex",
        justifyContent: "center",
        padding: 10,
        color: "#999",
      }}
    >
      <div style={{ display: "flex" }}>
        <div className="x-position">[{Math.trunc(rectangleValue.x)},</div>
        <div className="y-position">{Math.trunc(rectangleValue.y)}]</div>
      </div>
    </div>
  );
}

/**
 * Container that allows dropping items onto it
 */
function Canvas({ children }) {
  let canvasRef;
  const [, drop] = useDrop({
    accept: [ItemTypes.RECTANGLE_CREATOR, ItemTypes.RECTANGLE],
    drop: (item, monitor) => {
      const clientOffset = monitor.getClientOffset();
      if (item.type === ItemTypes.RECTANGLE_CREATOR) {
        item.dropPosition = viewportToCanvasPosition(canvasRef, {
          x: clientOffset.x,
          y: clientOffset.y,
        });
      } else if (item.type === ItemTypes.RECTANGLE) {
        item.dropPosition = viewportToCanvasPosition(canvasRef, {
          x: clientOffset.x,
          y: clientOffset.y,
        });
      }
      return { name: "Canvas", allowedDropEffect: "any" };
    },
  });
  return (
    <div
      data-testid="canvas"
      ref={(element) => {
        canvasRef = element;
        drop(element);
      }}
      style={{
        width: "100%",
        height: 500,
        position: "relative",
      }}
    >
      {children}
    </div>
  );
}

const ItemTypes = {
  RECTANGLE_CREATOR: "rectangle_creator",
  RECTANGLE: "rectangle",
};

/**
 * Element that can be dragged onto the canvas to create rectangles on the dropped position
 */
function RectangleCreator({ onCreate }) {
  const width = 60;
  const height = 60;
  const [, drag] = useDrag({
    item: { type: ItemTypes.RECTANGLE_CREATOR, width, height },
    end: (item, monitor) => {
      if (item.dropPosition) {
        const id = Date.now().toString();
        const rectangle = {
          id,
          // Subtract width and height to anchor on the middle, not top-left
          x: item.dropPosition.x - width / 2,
          y: item.dropPosition.y - height / 2,
          width,
          height,
        };
        onCreate(rectangle);
      }
    },
  });
  return (
    <>
      <div
        ref={drag}
        data-testid="rectangle-creator"
        style={{ backgroundColor: "#999", width: 30, height: 30 }}
      ></div>
    </>
  );
}

const rectangleAtom = memoize((rectangle) =>
  atom({ key: `rectangle#${rectangle.id}`, default: rectangle })
);

/**
 * Displays rectangle that can be moved by dragging it on the canvas
 */
function Rectangle({ rectangle }) {
  const [rectangleState, setRectangleState] = useRecoilState(
    rectangleAtom(rectangle)
  );
  const setPosition = ({ x, y }) => {
    setRectangleState({
      ...rectangle,
      // Subtract width and height to anchor on the middle, not top-left
      x: x - rectangleState.width / 2,
      y: y - rectangleState.height / 2,
    });
  };
  const [{ isDragging }, drag] = useDrag({
    item: {
      type: ItemTypes.RECTANGLE,
      width: rectangle.width,
      height: rectangle.height,
    },
    end: (item) => {
      if (item.dropPosition) {
        setPosition(item.dropPosition);
      }
    },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });
  const opacity = isDragging ? 0.4 : 1;
  return (
    <div
      ref={drag}
      className="rectangle"
      style={{
        margin: 5,
        backgroundColor: "#999",
        left: rectangleState.x,
        top: rectangleState.y,
        width: rectangleState.width,
        height: rectangleState.height,
        position: "absolute",
        opacity,
        cursor: "move",
      }}
    />
  );
}

// Convert viewport-relative positions to canvas-relative positions
function viewportToCanvasPosition(canvasRef, viewportPosition) {
  const canvasRect = canvasRef.getBoundingClientRect();
  let x = viewportPosition.x;
  x = x - canvasRect.left; // Convert mouse position which is relative to viewport, to a position relative to canvas
  let y = viewportPosition.y;
  y = y - canvasRect.top; // Convert mouse position which is relative to viewport, to a position relative to canvas
  return { x, y };
}
```

Lifting state up introduced a potential performance problem, now moving a rectangle across the canvas triggers a re-render on every other rectangle on screen. Feel free to open React Dev Tools, turn on "Highlight updates when components render" to see how the root component re-renders, triggering re-renders on its children as well.

<div
  style={{
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "100%",
    marginTop: 20,
    marginBottom: 20,
  }}
>
  <img src="/shared-state.gif" style={{ width: "80%" }} />
</div>

Possible solutions

- Use context. Top level context for each rectangle could solve sharing info between rectangles and rectangle info. It would work, but each new rectangle would require adding a context provider to the top of the react tree, which would force react to unmount and remount the whole tree. But if performance is a goal (it should not always be a goal, but sometimes it is, then we should try to avoid this expensive operation.
- Use recoil to share state, which you'll see how it's done on the next and final step

## Step 3: Shared state with recoil

It's time to refactor the prototype to use Recoil. Thanks to the tests, you can safely make changes to the implementation and be confident that everything is still working as intented.

The goal is to push rectangle's position info from the root component onto each `Rectangle`, and share this information with each rectangle's associated `RectangleInfo`. This way, moving a rectangle results in re-rendering only itself and its corresponding `RectangleInfo`.

First step is wrapping the app with a `RecoilRoot` component, which allows it's children to access Recoil's utilities.

Recoil also provides a hook called `useRecoilState` that has a similar signature to React's `useState`, meaning it returns a two-element array with the state as it's first item, and a state modifying function as second argument. One of it's benefits is that we can call `useRecoilValue` in another component in order to read the state defined in `useRecoilState`. The unit that Recoil uses to keep track of state is called `atom`, which both hooks receive as initializer. Passing both of them the same atom allows `useRecoilValue` to update when calling the state modifying function that `useRecoilState` returns.

To share information between `Rectangle` and `RectangleInfo`, the app will create an atom for each rectangle. Inspired by Recoil's talk, I implemented a function called `rectangleAtom` that takes an `id` as argument, and returns an atom associated with that id.

Having defined `rectangleAtom`, sharing them between components is a matter of adding `useRecoilState` to `Rectangle` and `useRecoilValue` to `RectangleInfo`.

```js
function RectangleInfo({ rectangle }) {
  const rectangleValue = useRecoilValue(rectangleAtom(rectangle));
  ...
}

function Rectangle({ rectangle }) {
  const [rectangleState, setRectangleState] = useRecoilState(
    rectangleAtom(rectangle)
  );
  ...
}

const rectangleAtom = memoize((rectangle) =>
  atom({ key: `rectangle#${rectangle.id}`, default: rectangle })
);
```

Take a look at the app now, notice that it's implementation changed but it's behaviour remained the same.

<DrawV3 />

```js codesandbox=recoil
import React, { useState } from "react";
import { DndProvider, useDrop, useDrag } from "react-dnd";
import Backend from "react-dnd-html5-backend";
import { RecoilRoot, atom, useRecoilValue, useRecoilState } from "recoil";
import memoize from "memoizee";

function Draw() {
  const [rectangles, setRectangles] = useState([]);

  return (
    <DndProvider backend={Backend}>
      <div style={{ width: "100%", border: "solid 1px #999" }}>
        <div style={{ display: "flex", flexDirection: "row" }}>
          <div
            data-testid="sidebar"
            style={{
              flexBasis: "100px",
              borderRight: "solid 1px #999",
              paddingTop: 50,
            }}
          >
            {rectangles.map((rectangle) => (
              <RectangleInfo key={rectangle.id} rectangle={rectangle} />
            ))}
          </div>
          <div style={{ flex: 1 }}>
            <div
              style={{
                width: "100%",
                height: 50,
                borderBottom: "solid 1px #999",
                padding: 10,
                display: "flex",
                alignItems: "center",
              }}
            >
              <RectangleCreator
                onCreate={(rectangle) => {
                  setRectangles([...rectangles, rectangle]);
                }}
              />
            </div>
            <Canvas>
              {rectangles.map((rectangle) => (
                <Rectangle key={rectangle.id} rectangle={rectangle} />
              ))}
            </Canvas>
          </div>
        </div>
      </div>
    </DndProvider>
  );
}

export default () => (
  <RecoilRoot>
    <Draw />
  </RecoilRoot>
);

function RectangleInfo({ rectangle }) {
  const rectangleValue = useRecoilValue(rectangleAtom(rectangle));
  return (
    <div
      className="rectangle-info"
      style={{
        display: "flex",
        justifyContent: "center",
        padding: 10,
        color: "#999",
      }}
    >
      <div style={{ display: "flex" }}>
        <div className="x-position">[{Math.trunc(rectangleValue.x)},</div>
        <div className="y-position">{Math.trunc(rectangleValue.y)}]</div>
      </div>
    </div>
  );
}

/**
 * Container that allows dropping items onto it
 */
function Canvas({ children }) {
  let canvasRef;
  const [, drop] = useDrop({
    accept: [ItemTypes.RECTANGLE_CREATOR, ItemTypes.RECTANGLE],
    drop: (item, monitor) => {
      const clientOffset = monitor.getClientOffset();
      if (item.type === ItemTypes.RECTANGLE_CREATOR) {
        item.dropPosition = viewportToCanvasPosition(canvasRef, {
          x: clientOffset.x,
          y: clientOffset.y,
        });
      } else if (item.type === ItemTypes.RECTANGLE) {
        item.dropPosition = viewportToCanvasPosition(canvasRef, {
          x: clientOffset.x,
          y: clientOffset.y,
        });
      }
      return { name: "Canvas", allowedDropEffect: "any" };
    },
  });
  return (
    <div
      data-testid="canvas"
      ref={(element) => {
        canvasRef = element;
        drop(element);
      }}
      style={{
        width: "100%",
        height: 500,
        position: "relative",
      }}
    >
      {children}
    </div>
  );
}

const ItemTypes = {
  RECTANGLE_CREATOR: "rectangle_creator",
  RECTANGLE: "rectangle",
};

/**
 * Element that can be dragged onto the canvas to create rectangles on the dropped position
 */
function RectangleCreator({ onCreate }) {
  const width = 60;
  const height = 60;
  const [, drag] = useDrag({
    item: { type: ItemTypes.RECTANGLE_CREATOR, width, height },
    end: (item, monitor) => {
      if (item.dropPosition) {
        const id = Date.now().toString();
        const rectangle = {
          id,
          // Subtract width and height to anchor on the middle, not top-left
          x: item.dropPosition.x - width / 2,
          y: item.dropPosition.y - height / 2,
          width,
          height,
        };
        onCreate(rectangle);
      }
    },
  });
  return (
    <>
      <div
        ref={drag}
        data-testid="rectangle-creator"
        style={{ backgroundColor: "#999", width: 30, height: 30 }}
      ></div>
    </>
  );
}

const rectangleAtom = memoize((rectangle) =>
  atom({ key: `rectangle#${rectangle.id}`, default: rectangle })
);

/**
 * Displays rectangle that can be moved by dragging it on the canvas
 */
function Rectangle({ rectangle }) {
  const [rectangleState, setRectangleState] = useRecoilState(
    rectangleAtom(rectangle)
  );
  const setPosition = ({ x, y }) => {
    setRectangleState({
      ...rectangle,
      // Subtract width and height to anchor on the middle, not top-left
      x: x - rectangleState.width / 2,
      y: y - rectangleState.height / 2,
    });
  };
  const [{ isDragging }, drag] = useDrag({
    item: {
      type: ItemTypes.RECTANGLE,
      width: rectangle.width,
      height: rectangle.height,
    },
    end: (item) => {
      if (item.dropPosition) {
        setPosition(item.dropPosition);
      }
    },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });
  const opacity = isDragging ? 0.4 : 1;
  return (
    <div
      ref={drag}
      className="rectangle"
      style={{
        margin: 5,
        backgroundColor: "#999",
        left: rectangleState.x,
        top: rectangleState.y,
        width: rectangleState.width,
        height: rectangleState.height,
        position: "absolute",
        opacity,
        cursor: "move",
      }}
    />
  );
}

// Convert viewport-relative positions to canvas-relative positions
function viewportToCanvasPosition(canvasRef, viewportPosition) {
  const canvasRect = canvasRef.getBoundingClientRect();
  let x = viewportPosition.x;
  x = x - canvasRect.left; // Convert mouse position which is relative to viewport, to a position relative to canvas
  let y = viewportPosition.y;
  y = y - canvasRect.top; // Convert mouse position which is relative to viewport, to a position relative to canvas
  return { x, y };
}
```

You can open up React dev tools again to see that moving a rectangle across the screen only updates the moved rectangle and the corresponding rectangle info component.

<div
  style={{
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "100%",
    marginTop: 20,
    marginBottom: 20,
  }}
>
  <img src="/recoil-state.gif" style={{ width: "80%" }} />
</div>

And that's it! Now the mini app shares state between components using Recoil instead of sharing state in the top level element.

## Summary

Played a bit with this example to learn how to use Recoil to share state between components instead of moving state to the root element.

- Wrote specifications for the app example
- Tested its drag and drop based features
- Implemented a simple version using react local state
- Used Recoil to share state between children instead of sharing state in root node

I hope this post sparked your interest and gave you some pointers on why sprinkling Recoil in your React components can help you avoid unnecesary re-renders. Recoil is a great tool to have at your disposal when running into performance issues, but keep in mind that it does not match `useState`'s simplicity, so as with every tool at your disposal, use it when the benefits outweight the costs.
